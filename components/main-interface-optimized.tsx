"use client"

import { useState, useEffect } from "react"
import { ChatInterface } from "@/components/chat-interface"
import { Sidebar } from "@/components/sidebar"
import { Header } from "@/components/header"
import { Button } from "@/components/ui/button"


import { MobileNav } from "@/components/mobile-nav"
import { useMediaQuery } from "@/hooks/use-media-query"
import { useHopeAISystem } from "@/hooks/use-hopeai-system"
import { HopeAISystemSingleton } from "@/lib/hopeai-system"
import { useSessionMetrics } from "@/hooks/use-session-metrics"
import { useConversationHistory } from "@/hooks/use-conversation-history"
import { usePioneerInvitation } from "@/hooks/use-pioneer-invitation"
import { usePatientChatSession } from "@/hooks/use-patient-chat-session"
import { PioneerCircleInvitation } from "@/components/pioneer-circle-invitation"
import { DebugPioneerInvitation } from "@/components/debug-pioneer-invitation"
import type { AgentType, ClinicalFile, PatientRecord, FichaClinicaState } from "@/types/clinical-types"
import { usePatientRecord } from "@/hooks/use-patient-library"
import FichaClinicaPanel from "@/components/patient-library/FichaClinicaPanel"
import { PatientContextComposer } from "@/lib/patient-summary-builder"
import * as Sentry from "@sentry/nextjs"

// Componente de m√©tricas de rendimiento (opcional, para desarrollo)
function PerformanceMetrics({ performanceReport }: { performanceReport: any }) {
  if (process.env.NODE_ENV !== 'development') return null

  return (
    <div className="fixed bottom-4 right-4 bg-black/80 text-white text-xs p-2 rounded-lg max-w-xs">
      <div className="font-semibold mb-1">M√©tricas de Rendimiento</div>
      <div>Sesi√≥n: {performanceReport.session.age}min</div>
      <div>Interacciones: {performanceReport.interactions.total}</div>
      <div>Resp. promedio: {Math.round(performanceReport.interactions.averageResponseTime)}ms</div>
      <div>Compresi√≥n: {(performanceReport.context.compressionRatio * 100).toFixed(1)}%</div>
      <div>Tokens: {performanceReport.context.tokenCount}</div>
      <div>Ventana: {performanceReport.context.contextWindowUtilization.toFixed(1)}%</div>
    </div>
  )
}

export function MainInterfaceOptimized({ showDebugElements = true }: { showDebugElements?: boolean }) {
  const [sidebarOpen, setSidebarOpen] = useState(false)
  const [mobileNavOpen, setMobileNavOpen] = useState(false)
  const [mobileNavInitialTab, setMobileNavInitialTab] = useState<'conversations' | 'patients'>('conversations')

  const [pendingFiles, setPendingFiles] = useState<ClinicalFile[]>([])
  const [isUploading, setIsUploading] = useState(false)
  const [isFichaOpen, setIsFichaOpen] = useState(false)
  const [fichasClinicasLocal, setFichasClinicasLocal] = useState<FichaClinicaState[]>([])
  const [isFichaLoading, setIsFichaLoading] = useState(false)
  const [isGenerateFichaLoading, setIsGenerateFichaLoading] = useState(false)
  const isMobile = useMediaQuery("(max-width: 768px)")

  // Usar el sistema HopeAI
  const {
    systemState,
    createSession,
    sendMessage,
    switchAgent,
    getHistory,
    clearError,
    addStreamingResponseToHistory,
    loadSession,
    setSessionMeta,
    resetSystem
  } = useHopeAISystem()

  // Selected patient for current session (must be before any conditional returns)
  const patientId = (systemState.sessionMeta && systemState.sessionMeta.patient?.reference) || null
  const { patient } = usePatientRecord(patientId)

  // Integraci√≥n de m√©tricas Sentry - Fase 1
  const {
    startSession: startMetricsSession,
    endSession: endMetricsSession,
    updateActivity,
    trackAgentChange,
    getSessionStats
  } = useSessionMetrics({
    userId: systemState.userId || "demo_user",
    sessionId: systemState.sessionId || "temp_session",
    currentAgent: systemState.activeAgent
  })

  // Hook para obtener el conteo real de conversaciones (fuente de verdad)
  const { totalCount: totalConversationsCount, loadConversations } = useConversationHistory()

  // Cargar conversaciones para asegurar que tenemos el conteo correcto
  useEffect(() => {
    const userId = systemState.userId || "demo_user"
    if (userId) {
      loadConversations(userId)
    }
  }, [systemState.userId, loadConversations])

  // Hook de invitaci√≥n al C√≠rculo de Pioneros
  const {
    shouldShowInvitation,
    markAsShown,
    recordResponse,
    eligibilityMetrics
  } = usePioneerInvitation({
    userId: systemState.userId || "demo_user",
    sessionId: systemState.sessionId || "temp_session",
    currentAgent: systemState.activeAgent,
    isActive: true,
    currentMessageCount: systemState.history?.length || 0, // Usar el count real
    totalConversations: totalConversationsCount || 0 // NUEVA: Pasar el conteo real de conversaciones
  })

  // Hook para gesti√≥n de conversaciones con pacientes
  const {
    startPatientConversation,
    isStartingConversation,
    error: patientConversationError,
    clearError: clearPatientError
  } = usePatientChatSession()

  // Debug logging para Pioneer Circle
  useEffect(() => {
    console.log('üîç Pioneer Circle Debug - Main Interface:', {
      totalConversationsFromHook: totalConversationsCount,
      currentMessageCount: systemState.history?.length || 0,
      shouldShowInvitation,
      eligibilityMetrics
    });
  }, [totalConversationsCount, systemState.history?.length, shouldShowInvitation, eligibilityMetrics])

  // Estado para controlar la creaci√≥n de sesi√≥n por defecto
  // Eliminado: no crear sesi√≥n por defecto; se crear√° en el primer env√≠o de mensaje
  // const [sessionCreationAttempted, setSessionCreationAttempted] = useState(false)

  // Cargar archivos pendientes cuando cambie la sesi√≥n
  useEffect(() => {
    const loadPendingFiles = async () => {
      if (systemState.sessionId) {
        try {
          const files = await HopeAISystemSingleton.getPendingFilesForSession(systemState.sessionId)
          setPendingFiles(files)
        } catch (error) {
          console.error('‚ùå Error cargando archivos pendientes:', error)
        }
      } else {
        setPendingFiles([])
      }
    }

    loadPendingFiles()
  }, [systemState.sessionId])
  
  // Crear sesi√≥n por defecto si no existe (optimizado para evitar condiciones de carrera)
  // Eliminado: la creaci√≥n autom√°tica de sesi√≥n provocaba sesiones vac√≠as
  // useEffect(() => { ... }, [])

  // Responsive sidebar management
  useEffect(() => {
    const handleResize = () => {
      // El sidebar permanece cerrado por defecto en todas las pantallas
      // Solo se cierra autom√°ticamente en m√≥viles si estaba abierto
      if (window.innerWidth < 768 && sidebarOpen) {
        setSidebarOpen(false)
      }
    }

    handleResize()
    window.addEventListener("resize", handleResize)
    return () => window.removeEventListener("resize", handleResize)
  }, [sidebarOpen])

  // Manejar cambio de agente con m√©tricas Sentry
  const handleAgentChange = async (agent: AgentType) => {
    if (systemState.sessionId) {
      console.log('üîÑ Cambiando a agente:', agent)
      
      // Instrumentaci√≥n Sentry para cambio de agente
      return Sentry.startSpan(
        {
          op: "agent.switch",
          name: `Switch Agent: ${systemState.activeAgent} -> ${agent}`,
        },
        async (span) => {
          try {
            span.setAttribute("agent.from", systemState.activeAgent)
            span.setAttribute("agent.to", agent)
            span.setAttribute("session.id", systemState.sessionId || "unknown_session")
            
            const success = await switchAgent(agent)
            
            if (success) {
              // Tracking de cambio de agente en m√©tricas
              trackAgentChange(systemState.activeAgent, agent)
              
              span.setAttribute("switch.success", true)
              span.setStatus({ code: 1, message: "Agent switch successful" })
              console.log('‚úÖ Agente cambiado exitosamente a:', agent)
            } else {
              span.setAttribute("switch.success", false)
              span.setStatus({ code: 2, message: "Agent switch failed" })
              console.error('‚ùå Error cambiando agente')
            }
            
            return success
          } catch (err) {
            span.setStatus({ code: 2, message: "Agent switch error" })
            Sentry.captureException(err)
            console.error('‚ùå Error en cambio de agente:', err)
            return false
          }
        }
      )
    }
    return false
  }

  // Funci√≥n de env√≠o de mensaje adaptada con m√©tricas
  const handleSendMessage = async (message: string, useStreaming = true) => {
    return Sentry.startSpan(
      {
        op: "message.send",
        name: "Send Message to HopeAI",
      },
      async (span) => {
        try {
          span.setAttribute("message.length", message.length)
          span.setAttribute("message.streaming", useStreaming)
          span.setAttribute("agent.current", systemState.activeAgent)
          span.setAttribute("session.id", systemState.sessionId || "unknown_session")
          span.setAttribute("attached_files_count", pendingFiles.length)
          
          // Validar que todos los archivos est√©n en estado 'active' antes de enviar
          const nonActiveFiles = pendingFiles.filter(file => 
            (file as any).processingStatus && (file as any).processingStatus !== 'active'
          )
          
          if (nonActiveFiles.length > 0) {
            const fileNames = nonActiveFiles.map(f => f.name).join(', ')
            const errorMessage = `No se puede enviar el mensaje. Los siguientes archivos a√∫n est√°n proces√°ndose: ${fileNames}. Por favor, espera a que terminen de procesarse.`
            console.warn('‚ö†Ô∏è Archivos no listos:', nonActiveFiles)
            throw new Error(errorMessage)
          }
          
          const startTime = Date.now()
          console.log('üì§ Enviando mensaje HopeAI:', message.substring(0, 50) + '...')
          console.log('üìé Archivos adjuntos:', pendingFiles.length)
          
          // Actualizar actividad del usuario
          updateActivity()
          
          // CRITICAL: Capturar archivos antes de env√≠o para mostrar inmediatamente en historial
          const attachedFilesForMessage = [...pendingFiles]
          
          const response = await sendMessage(message, useStreaming, attachedFilesForMessage)
          
          // Limpiar archivos pendientes despu√©s del env√≠o exitoso
          setPendingFiles([])
          console.log('üßπ Archivos pendientes limpiados despu√©s del env√≠o exitoso')
          
          const responseTime = Date.now() - startTime
          span.setAttribute("message.response_time", responseTime)
          span.setAttribute("message.success", true)
          span.setStatus({ code: 1, message: "Message sent successfully" })
          
          console.log('‚úÖ Mensaje enviado exitosamente')
          return response
        } catch (error) {
          span.setAttribute("message.success", false)
          span.setStatus({ code: 2, message: "Message send failed" })
          Sentry.captureException(error)
          console.error('‚ùå Error enviando mensaje:', error)
          throw error
        }
      }
    )
  }

  // Manejar respuesta de invitaci√≥n al C√≠rculo de Pioneros
  const handlePioneerResponse = (response: 'interested' | 'not_now' | 'not_interested') => {
    recordResponse(response)
    
    // Log para tracking
    console.log('üéØ Respuesta Pioneer Circle:', {
      userId: systemState.userId,
      sessionId: systemState.sessionId,
      response,
      eligibilityMetrics
    })
    
    // Enviar evento a Sentry para analytics
    Sentry.addBreadcrumb({
      message: 'Pioneer Circle Response',
      category: 'user_engagement',
      data: {
        user_id: systemState.userId,
        session_id: systemState.sessionId,
        response,
        message_count: eligibilityMetrics.messageCount,
        session_duration_minutes: Math.round(eligibilityMetrics.sessionDuration / 1000 / 60)
      }
    })
  }

  // Mostrar invitaci√≥n cuando sea elegible
  const handleShowPioneerInvitation = () => {
    markAsShown()
    console.log('üìã Invitaci√≥n Pioneer Circle mostrada')
  }

  // Manejar inicio de conversaci√≥n con paciente
  const handlePatientConversationStart = async (patient: PatientRecord, initialMessage?: string) => {
    try {
      console.log('üè• Iniciando conversaci√≥n con paciente:', patient.displayName)
      
      // Limpiar cualquier error previo
      if (patientConversationError) {
        clearPatientError()
      }
      
      // Iniciar conversaci√≥n con paciente usando el hook especializado
      const sessionId = await startPatientConversation(patient, initialMessage)
      
      if (sessionId) {
        console.log('‚úÖ Conversaci√≥n con paciente iniciada exitosamente:', sessionId)
        
        // CR√çTICO: Cargar la nueva sesi√≥n en el sistema principal
        const loadSuccess = await loadSession(sessionId)
        
        if (loadSuccess) {
          console.log('‚úÖ Sesi√≥n del paciente cargada en el sistema principal:', sessionId)
          
          // Crear y establecer el contexto del paciente en el sistema
          const composer = new PatientContextComposer()
          const patientSessionMeta = composer.createSessionMetadata(
            patient,
            {
              sessionId,
              userId: systemState.userId || "demo_user",
              clinicalMode: "clinical",
              activeAgent: systemState.activeAgent
            }
          )
          
          // Establecer el contexto del paciente en el sistema
          setSessionMeta(patientSessionMeta)
          console.log('üè• Contexto del paciente establecido en el sistema:', patient.displayName)
        } else {
          console.error('‚ùå Error cargando sesi√≥n del paciente en el sistema principal')
        }
      } else {
        console.error('‚ùå Error iniciando conversaci√≥n con paciente')
      }
    } catch (error) {
      console.error('‚ùå Error en handlePatientConversationStart:', error)
    }
  }

  // Funci√≥n de subida de documentos usando HopeAI System con estado reactivo
  const handleUploadDocument = async (file: File) => {
    // Ensure we have a session ID to associate the upload with
    let sessionIdForUpload: string | null = systemState.sessionId
    if (!sessionIdForUpload) {
      try {
        const userId = systemState.userId || 'demo_user'
        const mode = systemState.mode || 'clinical_supervision'
        const agent = systemState.activeAgent || 'socratico'
        const sid = await createSession(userId, mode, agent)
        if (!sid) throw new Error('No se pudo crear la sesi√≥n para subir documento')
        sessionIdForUpload = sid
      } catch (e) {
        console.error('‚ùå No se pudo crear sesi√≥n para subir documento', e)
        throw e
      }
    }

    setIsUploading(true) // ‚≠ê Bloquear chat mientras se sube archivo
    
    try {
      console.log('üìé Subiendo documento:', file.name)
      
      // Usar el sistema HopeAI para subir el documento
      const uploadedFile = await HopeAISystemSingleton.uploadDocument(
        sessionIdForUpload as string,
        file,
        systemState.userId || 'demo_user'
      )
      
      // Agregar archivo con estado inicial de procesamiento
      setPendingFiles(prev => [...prev, {
        ...uploadedFile,
        processingStatus: uploadedFile.status === 'processed' ? 'active' : 'processing'
      }])
      
      // Si el archivo a√∫n est√° procesando, iniciar polling para verificar estado
      if (uploadedFile.status !== 'processed') {
        pollFileStatus(uploadedFile.id, uploadedFile.geminiFileId)
      }
      
      console.log('‚úÖ Documento subido exitosamente:', uploadedFile.name)
      return uploadedFile
    } catch (error) {
      console.error('‚ùå Error subiendo documento:', error)
      throw error
    } finally {
      setIsUploading(false) // ‚≠ê Desbloquear chat
    }
  }

  // Funci√≥n para verificar el estado de procesamiento de archivos
  const pollFileStatus = async (fileId: string, geminiFileId?: string) => {
    if (!geminiFileId) return
    
    const maxAttempts = 30 // 60 segundos m√°ximo (2s * 30)
    let attempts = 0
    
    const checkStatus = async () => {
      try {
        attempts++
        
        // Verificar estado del archivo en Google GenAI
        const response = await fetch('/api/check-file-status', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ geminiFileId })
        })
        
        if (response.ok) {
          const { state } = await response.json()
          
          setPendingFiles(prev => prev.map(file => 
            file.id === fileId 
              ? { ...file, processingStatus: state === 'ACTIVE' ? 'active' : 'processing' }
              : file
          ))
          
          if (state === 'ACTIVE') {
            console.log('‚úÖ Archivo procesado y listo:', fileId)
            return
          }
          
          if (state === 'FAILED') {
            console.error('‚ùå Archivo fall√≥ en procesamiento:', fileId)
            setPendingFiles(prev => prev.map(file => 
              file.id === fileId 
                ? { ...file, processingStatus: 'error' }
                : file
            ))
            return
          }
        }
        
        // Continuar polling si no ha alcanzado el m√°ximo de intentos
        if (attempts < maxAttempts) {
          setTimeout(checkStatus, 2000) // Verificar cada 2 segundos
        } else {
          console.warn('‚ö†Ô∏è Timeout verificando estado del archivo:', fileId)
          setPendingFiles(prev => prev.map(file => 
            file.id === fileId 
              ? { ...file, processingStatus: 'timeout' }
              : file
          ))
        }
      } catch (error) {
        console.error('‚ùå Error verificando estado del archivo:', error)
        setPendingFiles(prev => prev.map(file => 
          file.id === fileId 
            ? { ...file, processingStatus: 'error' }
            : file
        ))
      }
    }
    
    // Iniciar verificaci√≥n despu√©s de 1 segundo
    setTimeout(checkStatus, 1000)
  }

  // Funci√≥n para remover archivos pendientes
  const handleRemoveFile = (fileId: string) => {
    setPendingFiles(prev => prev.filter(file => file.id !== fileId))
  }

  // Handle new conversation - Delegado completamente al Sidebar para evitar duplicaci√≥n
  const handleNewConversation = async () => {
    // La l√≥gica de creaci√≥n de sesi√≥n se maneja completamente en el Sidebar
    // para evitar la creaci√≥n duplicada de sesiones
    console.log('üîÑ Main: Delegando creaci√≥n de nueva conversaci√≥n al Sidebar')
  }

  // Handle conversation selection from history
  const handleConversationSelect = async (sessionId: string) => {
    try {
      console.log('üîÑ Cargando conversaci√≥n desde historial:', sessionId)
      const success = await loadSession(sessionId)
      if (success) {
        console.log('‚úÖ Conversaci√≥n cargada exitosamente')
        // Close sidebar and mobile nav on mobile after selecting conversation
        if (isMobile) {
          setSidebarOpen(false)
          setMobileNavOpen(false) // Also close mobile nav
        }
      } else {
        console.error('‚ùå Error cargando la conversaci√≥n')
      }
    } catch (err) {
      console.error('‚ùå Error al cargar conversaci√≥n:', err)
    }
  }

  // Crear objeto de sesi√≥n compatible con ChatInterface
  const compatibleSession = systemState.sessionId ? {
    sessionId: systemState.sessionId,
    userId: systemState.userId,
    mode: systemState.mode,
    activeAgent: systemState.activeAgent,
    history: systemState.history, // Usar directamente systemState.history para reactividad
    metadata: {
      createdAt: new Date(),
      lastUpdated: new Date(),
      totalTokens: systemState.history.length * 100, // Estimaci√≥n aproximada
      fileReferences: []
    },
    clinicalContext: {
      sessionType: systemState.mode,
      confidentialityLevel: 'high' as const
    }
  } : null

  // Estados de carga y error
  if (!systemState.isInitialized) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-background">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-foreground/80">Inicializando HopeAI System...</p>
          <p className="text-sm text-foreground/60 mt-2">Cargando contexto y configuraciones avanzadas</p>
        </div>
      </div>
    )
  }

  const handleGenerateFichaFromChat = async () => {
    try {
      setIsGenerateFichaLoading(true)
      if (!systemState.sessionId || !patient) return
      const sessionState = {
        sessionId: systemState.sessionId,
        userId: systemState.userId,
        mode: systemState.mode,
        activeAgent: systemState.activeAgent,
        history: systemState.history,
        metadata: { createdAt: new Date(), lastUpdated: new Date(), totalTokens: 0, fileReferences: [] },
        clinicalContext: {
          patientId: patient.id,
          supervisorId: undefined,
          sessionType: systemState.mode,
          confidentialityLevel: patient.confidentiality?.accessLevel || 'medium'
        }
      }
      const patientForm = {
        displayName: patient.displayName,
        demographics: patient.demographics,
        tags: patient.tags,
        notes: patient.notes,
        confidentiality: patient.confidentiality
      }
      const conversationSummary = systemState.history.slice(-6).map(m => `${m.role === 'user' ? 'Paciente' : 'Modelo'}: ${m.content}`).join('\n')
      const fichaId = `ficha_${patient.id}_${Date.now()}`

      const res = await fetch(`/api/patients/${encodeURIComponent(patient.id)}/ficha`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ fichaId, sessionId: systemState.sessionId, sessionState, patientForm, conversationSummary })
      })
      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data.error || 'Error generando ficha cl√≠nica')
      }
      await refreshFichaList()
      setIsFichaOpen(true)
    } catch (err) {
      console.error('‚ùå Error generando ficha cl√≠nica desde chat:', err)
    } finally {
      setIsGenerateFichaLoading(false)
    }
  }

  const handleOpenFichaFromChat = async () => {
    try {
      setIsFichaLoading(true)
      await refreshFichaList()
      setIsFichaOpen(true)
    } finally {
      setIsFichaLoading(false)
    }
  }

  const refreshFichaList = async () => {
    if (!patient) return
    try {
      const res = await fetch(`/api/patients/${encodeURIComponent(patient.id)}/ficha`)
      const data = await res.json()
      if (res.ok && Array.isArray(data.items)) {
        setFichasClinicasLocal(data.items)
      }
    } catch (e) {
      console.error('Error loading fichas cl√≠nicas:', e)
    }
  }

  if (systemState.error) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-background">
        <div className="text-center">
          <div className="text-destructive mb-4">Error: {systemState.error}</div>
          <div className="space-x-2">
            <Button
              onClick={clearError}
              variant="outline"
            >
              Limpiar Error
            </Button>
            <Button
              onClick={() => window.location.reload()}
            >
              Reiniciar
            </Button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="flex min-h-[100dvh] h-[100dvh] md:h-screen overflow-hidden bg-background font-sans">
      <Sidebar 
        isOpen={sidebarOpen} 
        onToggle={() => setSidebarOpen(!sidebarOpen)}
        userId={systemState.userId || "demo_user"}
        createSession={createSession}
        onConversationSelect={handleConversationSelect}
        onPatientConversationStart={handlePatientConversationStart}
        onNewChat={() => {
          // Reset local pending UI state and HopeAI system
          setPendingFiles([])
          // Clear HopeAI state so ChatInterface shows welcome and first send lazily creates a session
          resetSystem()
          // Optionally close sidebar on mobile
          if (isMobile) setSidebarOpen(false)
        }}
      />

      <div className="flex-1 flex flex-col overflow-hidden">
        <Header 
          onHistoryToggle={() => setMobileNavOpen(true)} 
          sessionMeta={systemState.sessionMeta}
        />

        {isMobile && (
          <MobileNav 
            userId={systemState.userId || "demo_user"}
            createSession={createSession}
            onConversationSelect={handleConversationSelect}
            isOpen={mobileNavOpen}
            onOpenChange={(open) => {
              setMobileNavOpen(open)
              if (!open) {
                // Reset to conversations tab when closing
                setMobileNavInitialTab('conversations')
              }
            }}
            onPatientConversationStart={handlePatientConversationStart}
            onNewChat={() => {
              setPendingFiles([])
              resetSystem()
            }}
            initialTab={mobileNavInitialTab}
          />
        )}

        <main className="flex-1 flex overflow-hidden">
          <div className="flex-1 flex flex-col overflow-hidden h-full min-h-0">
            <ChatInterface
              activeAgent={systemState.activeAgent}
              isProcessing={systemState.isLoading}
              isUploading={isUploading}
              currentSession={compatibleSession}
              sendMessage={handleSendMessage}
              uploadDocument={handleUploadDocument}
              addStreamingResponseToHistory={addStreamingResponseToHistory}
              pendingFiles={pendingFiles}
              onRemoveFile={handleRemoveFile}
              transitionState={systemState.transitionState}
              onGenerateFichaClinica={patient ? handleGenerateFichaFromChat : undefined}
              onOpenFichaClinica={patient ? handleOpenFichaFromChat : undefined}
              onOpenPatientLibrary={() => {
                setMobileNavInitialTab('patients')
                setMobileNavOpen(true)
              }}
              hasExistingFicha={(fichasClinicasLocal && fichasClinicasLocal.length > 0) || false}
              fichaLoading={isFichaLoading}
              generateLoading={isGenerateFichaLoading}
            />
            {patient && (
              <FichaClinicaPanel
                open={isFichaOpen}
                onOpenChange={setIsFichaOpen}
                patient={patient}
                fichas={fichasClinicasLocal}
                onRefresh={refreshFichaList}
                onGenerate={handleGenerateFichaFromChat}
              />
            )}
          </div>
        </main>
      </div>

      {shouldShowInvitation && (
        <PioneerCircleInvitation
          isOpen={shouldShowInvitation}
          onClose={handleShowPioneerInvitation}
          onResponse={handlePioneerResponse}
          userMetrics={{
            messageCount: eligibilityMetrics.messageCount,
            sessionDuration: eligibilityMetrics.sessionDuration
          }}
          currentAgent={systemState.activeAgent}
        />
      )}

      {systemState.sessionId && process.env.NODE_ENV === 'development' && showDebugElements && (
        <div className="fixed bottom-4 right-4 bg-card text-card-foreground p-2 rounded-lg shadow-lg text-xs border border-border">
           <div>Sesi√≥n: {systemState.sessionId}</div>
           <div>Agente: {systemState.activeAgent}</div>
           <div>Mensajes: {systemState.history.length}</div>
           {systemState.routingInfo && (
             <div>Intent: {systemState.routingInfo.detectedIntent}</div>
           )}
         </div>
       )}
    </div>
  )
}